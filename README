
JMatrix is a dense matrix library which allows manual placement of results
and intermediate computations in order to avoid garbage collection.

Supported matrix decompositions:

  LU decomposition.
  QR decomposition (full and reduced forms).
  SVD: singular value decomposition (full and reduced forms).
  Cholesky decomposition (for positive-definite matrices, LL and LDL forms).

Further supported features:

  Unary and binary elementwise operations.
  Orthogonalization by the Gram-Schmidt process.
  Solving equations by back substitution for triangular matrices.

-------------------------------------------------------------------------------
INSTALLATION:

  Make sure you have a java compiler installed, preferrably 1.8 or higher.
  To test this, issue: javac -version

  To run the tests and the benchmarks, install junit4.
  The junit4.jar file should be located in the directory specified in
  the java-libs proeprty of the build.xml file (by default: /usr/share/java).
  
  These requirements can be simply met on an Ubuntu system by:
  
    sudo apt install default-jdk junit4

-------------------------------------------------------------------------------
COMPILATION, TESTS, AND BENCHMARKS:

Compilation:

  ant compile
  ant jar

Generating documentation:

  ant doc

Running tests:

  Running all test cases:

    ant test

  Running a single test case (e.g., basicReducedSVD in MatrixTests):

    ant test-single -Dtestcase=MatrixTests#basicReducedSVD

Running benchmarks:

  Running all benchmarks with a randomly generated seed:

    ant bench

  Specifying the random seed (e.g., 17192331):

    ant bench -Dseed=17192331

  Specifying the benchmarks (e.g., running the LU, QR, and SVD benchmarks):

    ant bench -Dbenchmarks=LU,QR,SVD

  For all the available benchmarks, see BENCHMARKS in BenchmarkRunner.

Cleaning:

  ant clean

-------------------------------------------------------------------------------
USAGE EXAMPLES:

Solution of A*x = b for x, where A is non-singular:

  Matrix A = Matrix.create(2., -3., -1., 2., NR,
                           4., -4., -1., 4., NR,
                           2., -5., -2., 2., NR,
                           0.,  2.,  1., 0.);
  Matrix b = Matrix.create(4., 4., 9., -5.).T();
  Matrix[] QR = A.QR(false); // without computing Q
  Matrix x = QR[1].backsU(QR[1].T().backsL(A.T().mul(b)));

Least squares solution of A*x = b for x, where A is full column rank:

  Matrix A = Matrix.create(1., 1., NR, 1., 2., NR, 1., 3., NR, 1., 4.);
  Matrix b = Matrix.create(6., 5., 7., 10.).T();
  Matrix[] LUP = A.T().mul(A).LU();
  Matrix x = LUP[1].backsU(LUP[0].backsL(LUP[2].mul(A.T().mul(b))));

